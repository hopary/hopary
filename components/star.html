<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    
<!-- 星星代码相关的脚本 -->
<script>
    const numStars = 170;
    const starContainer = document.body;
    const gridRows = 5;
    const gridCols = 5;
    const minStarsPerGrid = 3;
    const bigStarThreshold = 6;

    // 生成指定范围内的随机整数
    function getRandomInt(min, max) {
        return Math.floor(Math.random() * (max - min + 1)) + min;
    }

    // 生成随机位置
    function randomPositionInGrid(gridX, gridY) {
        const gridWidth = window.innerWidth / gridCols;
        const gridHeight = window.innerHeight / gridRows;
        const minX = gridX * gridWidth;
        const maxX = (gridX + 1) * gridWidth;
        const minY = gridY * gridHeight;
        const maxY = (gridY + 1) * gridHeight;
        return {
            x: Math.random() * (maxX - minX) + minX,
            y: Math.random() * (maxY - minY) + minY
        };
    }

    // 生成随机星星大小
    function randomSize() {
        const originalMin = 2;
        const newMin = Math.ceil(originalMin * 1.4);
        const originalMax = 5;
        const firstIncreaseMax = originalMax * 1.3;
        const newMax = firstIncreaseMax * 1.3;
        return getRandomInt(newMin, newMax);
    }

    // 创建星星
    function createStar(gridX, gridY) {
        const star = document.createElement('div');
        star.classList.add('star');
        const initialPos = randomPositionInGrid(gridX, gridY);
        star.style.left = initialPos.x + 'px';
        star.style.top = initialPos.y + 'px';

        const size = randomSize();
        star.style.width = size + 'px';
        star.style.height = size + 'px';

        if (size >= bigStarThreshold) {
            const animationDelay = Math.random() * 5;
            const originalAnimationDuration = Math.random() * 3 + 2;
            const animationDuration = originalAnimationDuration / (1 + 0.2);
            star.style.animation = `twinkle ${animationDuration}s ease-in-out infinite alternate`;
            star.style.animationDelay = `${animationDelay}s`;
        } else {
            star.style.animation = 'none';
        }

        return { element: star, gridX, gridY, size };
    }

    const gridStarCounts = Array.from({ length: gridRows }, () => Array(gridCols).fill(0));
    const stars = [];

    function moveStar(star, currentGridX, currentGridY) {
        const possibleGridX = [currentGridX];
        const possibleGridY = [currentGridY];
        if (currentGridX > 0) possibleGridX.push(currentGridX - 1);
        if (currentGridX < gridCols - 1) possibleGridX.push(currentGridX + 1);
        if (currentGridY > 0) possibleGridY.push(currentGridY - 1);
        if (currentGridY < gridRows - 1) possibleGridY.push(currentGridY + 1);

        let newGridX, newGridY;
        do {
            newGridX = possibleGridX[getRandomInt(0, possibleGridX.length - 1)];
            newGridY = possibleGridY[getRandomInt(0, possibleGridY.length - 1)];
        } while (gridStarCounts[currentGridY][currentGridX] <= minStarsPerGrid && (newGridX!== currentGridX || newGridY!== currentGridY));

        gridStarCounts[currentGridY][currentGridX]--;
        gridStarCounts[newGridY][newGridX]++;

        const newPos = randomPositionInGrid(newGridX, newGridY);
        void star.offsetWidth;
        const previousTransitionTime = 20 * (1 + 0.4);
        const transitionTime = previousTransitionTime * (1 + 0.3);
        star.style.transition = `left ${transitionTime}s linear, top ${transitionTime}s linear`;
        star.style.left = newPos.x + 'px';
        star.style.top = newPos.y + 'px';

        function animate() {
            requestAnimationFrame(() => moveStar(star, newGridX, newGridY));
        }
        setTimeout(animate, transitionTime * 1000);
    }

    const fragment = document.createDocumentFragment();
    let starCount = 0;

    // 填充每个网格的最小星星数量
    for (let row = 0; row < gridRows; row++) {
        for (let col = 0; col < gridCols; col++) {
            while (gridStarCounts[row][col] < minStarsPerGrid && starCount < numStars) {
                const starData = createStar(col, row);
                fragment.appendChild(starData.element);
                gridStarCounts[row][col]++;
                stars.push(starData);
                starCount++;
            }
        }
    }

    // 随机分配剩余的星星
    while (starCount < numStars) {
        const randomRow = getRandomInt(0, gridRows - 1);
        const randomCol = getRandomInt(0, gridCols - 1);
        const starData = createStar(randomCol, randomRow);
        fragment.appendChild(starData.element);
        gridStarCounts[randomRow][randomCol]++;
        stars.push(starData);
        starCount++;
    }

    starContainer.appendChild(fragment);

    // 淘汰最小的 20% 的星星
    stars.sort((a, b) => a.size - b.size);
    const numToRemove = Math.floor(stars.length * 0.2);
    for (let i = 0; i < numToRemove; i++) {
        const starToRemove = stars.shift();
        starToRemove.element.remove();
        gridStarCounts[starToRemove.gridY][starToRemove.gridX]--;
    }

    for (let i = 0; i < stars.length; i++) {
        setTimeout(() => moveStar(stars[i].element, stars[i].gridX, stars[i].gridY), Math.random() * 3000);
    }
</script>



</body>
</html>