<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
  <style>
    /* 定义星星动画 */
    @keyframes twinkle {
      from {
        opacity: 1;
      }
      to {
        opacity: 0.2;
      }
    }

    /* 星星样式 */
    .star {
      position: absolute;
      background-color: white;
      border-radius: 50%;
      pointer-events: none;
    }
  </style>
</head>

<body>
  <!-- 星星代码相关的脚本 -->
  <script>
    // 配置参数
    const CONFIG = {
      numStars: 170,
      gridRows: 5,
      gridCols: 5,
      minStarsPerGrid: 3,
      bigStarThreshold: 6,
      transitionTimeMultiplier: 20 * 1.4 * 1.3,
      animationDelayMax: 5,
      animationDurationMin: 2,
      animationDurationMax: 5
    };

    const starContainer = document.body;
    const gridStarCounts = Array.from({ length: CONFIG.gridRows }, () => Array(CONFIG.gridCols).fill(0));
    const stars = [];

    // 生成指定范围内的随机整数
    function getRandomInt(min, max) {
      return Math.floor(Math.random() * (max - min + 1)) + min;
    }

    // 生成随机位置
    function randomPositionInGrid(gridX, gridY) {
      const gridWidth = window.innerWidth / CONFIG.gridCols;
      const gridHeight = window.innerHeight / CONFIG.gridRows;
      const minX = gridX * gridWidth;
      const maxX = (gridX + 1) * gridWidth;
      const minY = gridY * gridHeight;
      const maxY = (gridY + 1) * gridHeight;
      return {
        x: Math.random() * (maxX - minX) + minX,
        y: Math.random() * (maxY - minY) + minY
      };
    }

    // 生成随机星星大小
    function randomSize() {
      const minSize = Math.ceil(2 * 1.4);
      const maxSize = Math.floor(5 * 1.3 * 1.3);
      return getRandomInt(minSize, maxSize);
    }

    // 创建星星
    function createStar(gridX, gridY) {
      const star = document.createElement('div');
      star.classList.add('star');
      const initialPos = randomPositionInGrid(gridX, gridY);
      star.style.left = initialPos.x + 'px';
      star.style.top = initialPos.y + 'px';

      const size = randomSize();
      star.style.width = size + 'px';
      star.style.height = size + 'px';

      if (size >= CONFIG.bigStarThreshold) {
        const animationDelay = Math.random() * CONFIG.animationDelayMax;
        const animationDuration = (Math.random() * (CONFIG.animationDurationMax - CONFIG.animationDurationMin) + CONFIG.animationDurationMin) / 1.2;
        star.style.animation = `twinkle ${animationDuration}s ease-in-out infinite alternate`;
        star.style.animationDelay = `${animationDelay}s`;
      }

      return { element: star, gridX, gridY, size };
    }

    // 移动星星
    function moveStar(starData) {
      const { element, gridX, gridY } = starData;
      const possibleGridX = [gridX];
      const possibleGridY = [gridY];
      if (gridX > 0) possibleGridX.push(gridX - 1);
      if (gridX < CONFIG.gridCols - 1) possibleGridX.push(gridX + 1);
      if (gridY > 0) possibleGridY.push(gridY - 1);
      if (gridY < CONFIG.gridRows - 1) possibleGridY.push(gridY + 1);

      let newGridX, newGridY;
      do {
        newGridX = possibleGridX[getRandomInt(0, possibleGridX.length - 1)];
        newGridY = possibleGridY[getRandomInt(0, possibleGridY.length - 1)];
      } while (gridStarCounts[gridY][gridX] <= CONFIG.minStarsPerGrid && (newGridX!== gridX || newGridY!== gridY));

      gridStarCounts[gridY][gridX]--;
      gridStarCounts[newGridY][newGridX]++;

      const newPos = randomPositionInGrid(newGridX, newGridY);
      element.style.transition = `left ${CONFIG.transitionTimeMultiplier}s linear, top ${CONFIG.transitionTimeMultiplier}s linear`;
      element.style.left = newPos.x + 'px';
      element.style.top = newPos.y + 'px';

      setTimeout(() => moveStar({ element, gridX: newGridX, gridY: newGridY }), CONFIG.transitionTimeMultiplier * 1000);
    }

    const fragment = document.createDocumentFragment();
    let starCount = 0;

    // 填充每个网格的最小星星数量
    for (let row = 0; row < CONFIG.gridRows; row++) {
      for (let col = 0; col < CONFIG.gridCols; col++) {
        while (gridStarCounts[row][col] < CONFIG.minStarsPerGrid && starCount < CONFIG.numStars) {
          const starData = createStar(col, row);
          fragment.appendChild(starData.element);
          gridStarCounts[row][col]++;
          stars.push(starData);
          starCount++;
        }
      }
    }

    // 随机分配剩余的星星
    while (starCount < CONFIG.numStars) {
      const randomRow = getRandomInt(0, CONFIG.gridRows - 1);
      const randomCol = getRandomInt(0, CONFIG.gridCols - 1);
      const starData = createStar(randomCol, randomRow);
      fragment.appendChild(starData.element);
      gridStarCounts[randomRow][randomCol]++;
      stars.push(starData);
      starCount++;
    }

    starContainer.appendChild(fragment);

    // 淘汰最小的 20% 的星星
    stars.sort((a, b) => a.size - b.size);
    const numToRemove = Math.floor(stars.length * 0.2);
    for (let i = 0; i < numToRemove; i++) {
      const starToRemove = stars.shift();
      starToRemove.element.remove();
      gridStarCounts[starToRemove.gridY][starToRemove.gridX]--;
    }

    // 启动星星移动
    stars.forEach(starData => {
      setTimeout(() => moveStar(starData), Math.random() * 3000);
    });

    // 处理窗口大小变化
    window.addEventListener('resize', () => {
      stars.forEach(starData => {
        const { element, gridX, gridY } = starData;
        const newPos = randomPositionInGrid(gridX, gridY);
        element.style.left = newPos.x + 'px';
        element.style.top = newPos.y + 'px';
      });
    });
  </script>
</body>

</html>
